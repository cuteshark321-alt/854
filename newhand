--这个范围没有限制
--newhand


local main = require(game:GetService("ReplicatedStorage").Util.CameraShaker.Main)
local returnnil = function() return nil end

main.StartShake = returnnil
main.ShakeOnce = returnnil
main.ShakeSustain = returnnil
main.CameraShakeInstance = returnnil
main.Shake = returnnil
main.Start = returnnil


game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "newhand脚本",
	Text = "newhand制作",
	Duration = 5;
})
wait(0.1)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera 
local workspace = game:GetService("Workspace")  
local Player = Players.LocalPlayer  
-- 修改UI連結為指定的GitHub連結
local ui = loadstring(game:HttpGet("https://raw.githubusercontent.com/cuteshark321-alt/854/main/UOI"))()  
local win = ui:new("newhand中心")
local UITab1 = win:Tab("公告",'7734068321')
local UITab2 = win:Tab("脚本",'7734068321')
local UITab3 = win:Tab("主要功能",'7734068321')
local UITab4 = win:Tab("透視",'7734068321')
local UITab5 = win:Tab("功能2",'7734068321')

local about = UITab1:section("公告",true)

about:Label("newhand制作")
about:Label("脚本測試中")
about:Label("更新繁體中文")
about:Label("增加自動v3")
about:Label("自動v3目前還在測試中")

local about = UITab2:section("脚本",true)
about:Slider("視覺缩放距离", "Slider",  128, 128, 100000, false, function(Value)
    game:GetService("Players").LocalPlayer.CameraMaxZoomDistance = Value
end)

-- ===================== 小傑腳本的自動V3功能（移植版）=====================
local autoV3Enabled = false
local autoV3Task = nil

local function callRaceV3Remote()
    local Remotes = game:GetService("ReplicatedStorage"):FindFirstChild("Remotes")
    if not Remotes then 
        print("未找到Remotes文件夾")
        return 
    end
    
    local CommE = Remotes:FindFirstChild("CommE")
    if not CommE then 
        print("未找到CommE遠程")
        return 
    end
    
    pcall(function()
        CommE:FireServer("ActivateAbility")
        print("已觸發V3能力")
    end)
end

local function startAutoV3()
    if autoV3Task then
        task.cancel(autoV3Task)
        autoV3Task = nil
    end
    
    autoV3Task = task.spawn(function()
        while autoV3Enabled do
            callRaceV3Remote()
            task.wait(1)
        end
        autoV3Task = nil
    end)
end

local function toggleAutoV3(state)
    autoV3Enabled = state
    
    if state then
        startAutoV3()
        print("自動V3功能已開啟")
    else
        if autoV3Task then
            task.cancel(autoV3Task)
            autoV3Task = nil
        end
        print("自動V3功能已關閉")
    end
end

-- 角色重生時自動重啟
LocalPlayer.CharacterAdded:Connect(function()
    if autoV3Enabled then
        task.wait(2)
        startAutoV3()
    end
end)

-- 添加UI控制
about:Toggle("自動V3", "Toggle", false, function(IsEnabled)
    toggleAutoV3(IsEnabled)
end)

-- ===================== 自動V4功能 =====================
local toggleKey = "自動V4"
local autoV4Task = nil

local function getToggleState(key)
    if not _G.ToggleStates then _G.ToggleStates = {} end
    return _G.ToggleStates[key] or false
end

local function callAwakeningRemote()
    local Backpack = LocalPlayer:FindFirstChild("Backpack")
    if not Backpack then return end
    
    local Awakening = Backpack:FindFirstChild("Awakening")
    if not Awakening then return end
    
    local RemoteFunc = Awakening:FindFirstChild("RemoteFunction")
    if not RemoteFunc or not RemoteFunc:IsA("RemoteFunction") then return end
    
    local success, err = pcall(function()
        RemoteFunc:InvokeServer(true)
    end)
    if not success then
        warn("自动v4调用失败：", err)
    end
end

local function toggleAutoV4(enable)
    if autoV4Task then
        task.cancel(autoV4Task)
        autoV4Task = nil
    end
    
    if enable then
        autoV4Task = task.spawn(function()
            while getToggleState(toggleKey) do
                callAwakeningRemote()
                task.wait(1) 
            end
            autoV4Task = nil
        end)
    end
end

about:Toggle(toggleKey, "Toggle", false, function(IsEnabled)
    if not _G.ToggleStates then _G.ToggleStates = {} end
    _G.ToggleStates[toggleKey] = IsEnabled
    
    toggleAutoV4(IsEnabled)
end)

-- 缝合功能
local about2 = UITab2:section("外部脚本",true)

about2:Button("飛行",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/cuteshark321-alt/854/refs/heads/main/newhand"))()
end)

about2:Button("法天象地",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/xiaoxuan-77/-/refs/heads/main/法天像地"))()
end)

about2:Button("redz",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/xiaoxuan-77/-/refs/heads/main/redz"))()
end)

about2:Button("皮脚本",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/xiaoxuan-77/-/refs/heads/main/皮"))()
end)

about2:Button("fps优化",function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/xiaoxuan-77/-/refs/heads/main/fps优化"))()
end)

about2:Button("地下",function()
	loadstring(game:HttpGet('https://raw.githubusercontent.com/56123asda/546546/refs/heads/main/%E5%9C%B0%E4%B8%8B'))()
end)

-- 防挂机检测
local VirtualUser = game:GetService("VirtualUser")
game:GetService("Players").LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new(0,0))
    print("newhand | 已攔截掛機檢測，持續運行中...")
end)

-- ===================== 原始範圍+快速攻擊功能 =====================
local attackTab = UITab3:section("範圍+快速攻擊",true)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local Player = Players.LocalPlayer
local _ENV = (getgenv or getrenv or getfenv)()
local Settings = {AutoClick = true, ClickDelay = 0.3}
Settings.Distance = 1000000000
local Module = {}
local _G = _G or getfenv(0)._G
_G.FastAttack = _G.FastAttack ~= nil and _G.FastAttack or true

local function SafeWaitForChild(parent, childName)
	local success, result = pcall(function() return parent:WaitForChild(childName, 10) end)
	if not success or not result then warn("未找到组件: " .. childName) end
	return result
end

local function CheckAndGetCoreComponents()
	local Remotes, Modules, Net, RegisterAttack, RegisterHit, Enemies = nil, nil, nil, nil, nil, nil
	while true do
		Remotes = SafeWaitForChild(ReplicatedStorage, "Remotes")
		Modules = SafeWaitForChild(ReplicatedStorage, "Modules")
		Net = Modules and SafeWaitForChild(Modules, "Net") or nil
		RegisterAttack = Net and SafeWaitForChild(Net, "RE/RegisterAttack") or nil
		RegisterHit = Net and SafeWaitForChild(Net, "RE/RegisterHit") or nil
		Enemies = SafeWaitForChild(workspace, "Enemies")
		if Remotes and Modules and Net and RegisterAttack and RegisterHit and Enemies then
			return Remotes, Net, RegisterAttack, RegisterHit, Enemies
		end
		warn("核心组件缺失，持续重试中...")
		task.wait(1)
	end
end

local function IsAlive(character)
	if not character then return false end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	return humanoid and humanoid.Health and humanoid.Health > 0
end

local function GetRandomValidPart(target)
	local allParts = target:GetDescendants()
	local validParts = {}
	local humanoidRootPart = target:FindFirstChild("HumanoidRootPart")
	local boneParts = humanoidRootPart and humanoidRootPart.Parent:GetDescendants() or {}
	for _, part in ipairs(allParts) do
		if part:IsA("BasePart") and part.CanCollide and table.find(boneParts, part) then
			table.insert(validParts, part)
		end
	end
	return #validParts > 0 and validParts[math.random(1, #validParts)] or target:FindFirstChild("HumanoidRootPart")
end

Module.FastAttack = (function()
	if _ENV.rz_FastAttack then return _ENV.rz_FastAttack end
	local FastAttack = {
		Distance = 1000000000,
		attackMobs = true,
		attackPlayers = true,
		Equipped = nil,
		IsRunning = _G.FastAttack,
		consecutiveFailures = 0,
		maxConsecutiveFailures = 5
	}

	local function ProcessEnemies(OthersEnemies, Folder)
		if not Folder or not FastAttack.attackMobs then return nil end
		local BasePart = nil
		for _, Enemy in Folder:GetChildren() do
			if Enemy == Player.Character or not IsAlive(Enemy) then continue end
			local foundPart = GetRandomValidPart(Enemy)
			if foundPart and Player:DistanceFromCharacter(foundPart.Position) < FastAttack.Distance then
				table.insert(OthersEnemies, {Enemy, foundPart})
				BasePart = foundPart
			end
		end
		return BasePart
	end

	local function ProcessRealPlayers(OthersEnemies)
		if not FastAttack.attackPlayers then return nil end
		local BasePart = nil
		for _, OtherPlayer in Players:GetPlayers() do
			if OtherPlayer == Player then continue end
			local OtherChar = OtherPlayer.Character
			if not IsAlive(OtherChar) then continue end
			local foundPart = GetRandomValidPart(OtherChar)
			if foundPart and Player:DistanceFromCharacter(foundPart.Position) < FastAttack.Distance then
				table.insert(OthersEnemies, {OtherChar, foundPart})
				BasePart = foundPart
			end
		end
		return BasePart
	end

	function FastAttack:Attack(BasePart, OthersEnemies)
		local _, Net, temp_RegisterAttack, temp_RegisterHit, _ = CheckAndGetCoreComponents()
		if not (BasePart and OthersEnemies and #OthersEnemies > 0 and temp_RegisterAttack and temp_RegisterHit) then
			self.consecutiveFailures = self.consecutiveFailures + 1
			if self.consecutiveFailures >= self.maxConsecutiveFailures then
				self.consecutiveFailures = 0
				self.Equipped = Player.Character and IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
			end
			task.delay(0.5, function() self:AttackNearest() end)
			return
		end
		self.consecutiveFailures = 0
		temp_RegisterAttack:FireServer(Settings.ClickDelay or 0)
		temp_RegisterHit:FireServer(BasePart, OthersEnemies)
	end

	function FastAttack:AttackNearest()
		if not self.IsRunning then return end
		local _, _, _, _, Enemies = CheckAndGetCoreComponents()
		local OthersEnemies = {}
		local Part1 = ProcessEnemies(OthersEnemies, Enemies)
		local Part2 = ProcessRealPlayers(OthersEnemies)
		if #OthersEnemies > 0 then
			self:Attack(Part1 or Part2, OthersEnemies)
		else
			task.wait(0)
		end
	end

	function FastAttack:BladeHits()
		if not self.IsRunning then return end
		local Equipped = Player.Character and IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
		if Equipped and Equipped.ToolTip ~= "Gun" then
			self:AttackNearest()
		else
			task.wait(0)
		end
	end

	task.spawn(function()
		while true do
			task.wait(Settings.ClickDelay)
			if Settings.AutoClick and FastAttack.IsRunning then
				FastAttack:BladeHits()
			else
				task.wait()
			end
		end
	end)

	_ENV.rz_FastAttack = FastAttack
	return FastAttack
end)()

-- UI控件绑定
attackTab:Toggle("開關", "FastAttackToggle", _G.FastAttack, function(state)
	if _ENV.rz_FastAttack then
		_ENV.rz_FastAttack.IsRunning = state
		_G.FastAttack = state
	end
end)

attackTab:Textbox("範圍", "AttackRange", "1000000000", function(text)
	local num = tonumber(text) or 1000000000
	num = math.floor(math.clamp(num, 1, 1000000000))
	if _ENV.rz_FastAttack then
		_ENV.rz_FastAttack.Distance = num
	end
end)

attackTab:Textbox("攻速", "ClickDelay", "0.000001", function(text)
	local num = tonumber(text) or 0.000001
	num = math.round(math.clamp(num, 0.000001, 2) * 100) / 100
	Settings.ClickDelay = num
end)

attackTab:Toggle("自動M1打怪", "AttackMobsToggle", true, function(state)
	if _ENV.rz_FastAttack then
		_ENV.rz_FastAttack.attackMobs = state
	end
end)

attackTab:Toggle("自動M1打人", "AttackPlayersToggle", true, function(state)
	if _ENV.rz_FastAttack then
		_ENV.rz_FastAttack.attackPlayers = state
	end
end)

-- 组件恢复逻辑
task.spawn(function()
	while true do
		task.wait(1)
		if not _ENV.rz_FastAttack then
			warn("⚠️ 快速攻击组件未完全加载，持续尝试恢复...")
			while not _ENV.rz_FastAttack do
				task.wait(0.5)
				if _G.FastAttack then
					local Remotes, Net, RegisterAttack, RegisterHit, Enemies = CheckAndGetCoreComponents()
					Module.FastAttack = Module.FastAttack or (function()
						local FastAttack = {
							Distance=100000,
							attackMobs=true,
							attackPlayers=true,
							Equipped=nil,
							IsRunning=_G.FastAttack,
							consecutiveFailures=0,
							maxConsecutiveFailures=5
						}

						local function ProcessEnemies(OthersEnemies, Folder)
							if not Folder or not FastAttack.attackMobs then return nil end
							local BasePart = nil
							for _, Enemy in Folder:GetChildren() do
								if Enemy == Player.Character or not IsAlive(Enemy) then continue end
								local foundPart = GetRandomValidPart(Enemy)
								if foundPart and Player:DistanceFromCharacter(foundPart.Position) < FastAttack.Distance then
									table.insert(OthersEnemies, {Enemy, foundPart})
									BasePart = foundPart
								end
							end
							return BasePart
						end

						local function ProcessRealPlayers(OthersEnemies)
							if not FastAttack.attackPlayers then return nil end
							local BasePart = nil
							for _, OtherPlayer in Players:GetPlayers() do
								if OtherPlayer == Player then continue end
								local OtherChar = OtherPlayer.Character
								if not IsAlive(OtherChar) then continue end
								local foundPart = GetRandomValidPart(OtherChar)
								if foundPart and Player:DistanceFromCharacter(foundPart.Position) < FastAttack.Distance then
									table.insert(OthersEnemies, {OtherChar, foundPart})
									BasePart = foundPart
								end
							end
							return BasePart
						end

						function FastAttack:Attack(BasePart, OthersEnemies)
							local _, Net, temp_RegisterAttack, temp_RegisterHit, _ = CheckAndGetCoreComponents()
							if not (BasePart and OthersEnemies and #OthersEnemies > 0 and temp_RegisterAttack and temp_RegisterHit) then
								self.consecutiveFailures = self.consecutiveFailures + 1
								if self.consecutiveFailures >= self.maxConsecutiveFailures then
									self.consecutiveFailures = 0
									self.Equipped = Player.Character and IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
								end
								task.delay(0.5, function() self:AttackNearest() end)
								return
							end
							self.consecutiveFailures = 0
							temp_RegisterAttack:FireServer(Settings.ClickDelay or 0)
							temp_RegisterHit:FireServer(BasePart, OthersEnemies)
						end

						function FastAttack:AttackNearest()
							if not self.IsRunning then return end
							local _, _, _, _, Enemies = CheckAndGetCoreComponents()
							local OthersEnemies = {}
							local Part1 = ProcessEnemies(OthersEnemies, Enemies)
							local Part2 = ProcessRealPlayers(OthersEnemies)
							if #OthersEnemies > 0 then
								self:Attack(Part1 or Part2, OthersEnemies)
							end
						end

						function FastAttack:BladeHits()
							local Equipped = Player.Character and IsAlive(Player.Character) and Player.Character:FindFirstChildOfClass("Tool")
							if Equipped and Equipped.ToolTip ~= "Gun" then
								self:AttackNearest()
							end
						end

						task.spawn(function()
							while true do
								task.wait(Settings.ClickDelay)
								if Settings.AutoClick and FastAttack.IsRunning then
									FastAttack:BladeHits()
								else
									task.wait(0.1)
								end
							end
						end)

						_ENV.rz_FastAttack = FastAttack
						return FastAttack
					end)()
				end
			end
		end
	end
end)

-- 移速功能
attackTab:Textbox("速度", "TranslateAccelSpeed", "輸入速度值", function(Value)
    local speed = tonumber(Value)
    if speed then
        getfenv().translateSpeed = speed
    end
end)

attackTab:Toggle("加速開關", "TranslateAccelToggle", false, function(State)
    getfenv().translateAccelEnabled = State
    
    if State then
        if getfenv().sudu then
            getfenv().sudu:Disconnect()
            getfenv().sudu = nil
        end
        
        getfenv().translateConnection = game:GetService("RunService").Heartbeat:Connect(function()
            if game:GetService("Players").LocalPlayer.Character and 
               game:GetService("Players").LocalPlayer.Character.Humanoid and 
               game:GetService("Players").LocalPlayer.Character.Humanoid.Parent then
               
                local humanoid = game:GetService("Players").LocalPlayer.Character.Humanoid
                
                if humanoid.MoveDirection.Magnitude > 0 then
                    local moveDirection = humanoid.MoveDirection
                    local acceleration = moveDirection * (getfenv().translateSpeed or 50) / 30
                    
                    game:GetService("Players").LocalPlayer.Character:TranslateBy(acceleration)
                end
            end
        end)
    else
        if getfenv().translateConnection then
            getfenv().translateConnection:Disconnect()
            getfenv().translateConnection = nil
        end
    end
end)

-- ===================== 改進的透視功能 =====================
-- 整合顯示：名稱 + 距離 + 血量
local espTab = UITab4:section("透視",true)

local ESPConfig = {
    MainSwitch = false,     -- 總開關
    ShowPlayerInfo = false, -- 顯示玩家信息（名稱+距離+血量）
    ShowTracer = false      -- 顯示射線追踪
}

local ESPElements = {}

-- 根據血量設定顏色
local function GetHealthColor(healthPercent)
    if healthPercent > 0.7 then
        return Color3.new(0, 1, 0)      -- 綠色：血量 > 70%
    elseif healthPercent > 0.3 then
        return Color3.new(1, 1, 0)      -- 黃色：30% < 血量 ≤ 70%
    else
        return Color3.new(1, 0, 0)      -- 紅色：血量 ≤ 30%
    end
end

-- 清理玩家ESP
local function CleanupPlayerESP(player)
    if not ESPElements[player.UserId] then return end
    
    -- 清理信息顯示
    if ESPElements[player.UserId].InfoESP then
        ESPElements[player.UserId].InfoESP:Destroy()
        ESPElements[player.UserId].InfoESP = nil
    end
    if ESPElements[player.UserId].InfoUpdateConn then
        ESPElements[player.UserId].InfoUpdateConn:Disconnect()
        ESPElements[player.UserId].InfoUpdateConn = nil
    end
    
    -- 清理射線追踪
    if ESPElements[player.UserId].Tracer then
        ESPElements[player.UserId].Tracer:Remove()
        ESPElements[player.UserId].Tracer = nil
    end
    if ESPElements[player.UserId].TracerConn then
        ESPElements[player.UserId].TracerConn:Disconnect()
        ESPElements[player.UserId].TracerConn = nil
    end
end

-- 創建玩家信息ESP（整合顯示）
local function CreatePlayerInfoESP(player)
    if not player.Character or not player.Character:FindFirstChild("Head") then return end
    
    local head = player.Character.Head
    
    -- 如果已存在，先清理
    if ESPElements[player.UserId] and ESPElements[player.UserId].InfoESP then
        ESPElements[player.UserId].InfoESP:Destroy()
        ESPElements[player.UserId].InfoESP = nil
    end
    
    -- 創建BillboardGui
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "PlayerInfoESP_" .. player.UserId
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(0, 200, 0, 40)  -- 加大寬度以容納更多信息
    billboardGui.StudsOffset = Vector3.new(0, 3, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.ClipsDescendants = false
    billboardGui.Parent = head
    
    -- 創建單一文本標籤顯示所有信息
    local infoLabel = Instance.new("TextLabel")
    infoLabel.Name = "PlayerInfoLabel"
    infoLabel.Parent = billboardGui
    infoLabel.BackgroundTransparency = 1
    infoLabel.Size = UDim2.new(1, 0, 1, 0)
    infoLabel.Position = UDim2.new(0, 0, 0, 0)
    infoLabel.TextColor3 = Color3.new(1, 1, 1)
    infoLabel.TextScaled = false
    infoLabel.TextSize = 16
    infoLabel.Font = Enum.Font.GothamSemibold
    infoLabel.TextStrokeTransparency = 0.7
    infoLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    infoLabel.TextXAlignment = Enum.TextXAlignment.Center
    infoLabel.TextYAlignment = Enum.TextYAlignment.Center
    
    -- 更新連接
    local updateConnection = RunService.RenderStepped:Connect(function()
        if not billboardGui.Parent or not LocalPlayer.Character or not player.Character then 
            return 
        end
        
        -- 檢查玩家是否存活
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            infoLabel.Text = player.Name .. " [死亡]"
            infoLabel.TextColor3 = Color3.new(0.5, 0.5, 0.5)
            return
        end
        
        -- 計算距離
        local localRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
        local distance = "??"
        
        if localRoot and targetRoot then
            local dist = (localRoot.Position - targetRoot.Position).Magnitude
            distance = string.format("%.1fm", dist)
        end
        
        -- 獲取血量信息
        local health = math.floor(humanoid.Health)
        local maxHealth = math.floor(humanoid.MaxHealth)
        local healthPercent = maxHealth > 0 and (health / maxHealth) or 0
        
        -- 設置文本顏色（基於血量）
        local textColor = GetHealthColor(healthPercent)
        
        -- 整合顯示所有信息在一行
        infoLabel.Text = string.format("%s | %s | %d/%d", 
            player.Name, distance, health, maxHealth)
        infoLabel.TextColor3 = textColor
    end)
    
    -- 存儲到ESPElements
    ESPElements[player.UserId] = ESPElements[player.UserId] or {}
    ESPElements[player.UserId].InfoESP = billboardGui
    ESPElements[player.UserId].InfoUpdateConn = updateConnection
end

-- 創建射線追踪
local function CreateTracerESP(player)
    -- 清理現有的射線
    if ESPElements[player.UserId] and ESPElements[player.UserId].Tracer then
        ESPElements[player.UserId].Tracer:Remove()
        ESPElements[player.UserId].Tracer = nil
    end
    
    -- 創建新的Drawing Line
    local tracer = Drawing.new("Line")
    tracer.Color = Color3.new(1, 0, 0)
    tracer.Thickness = 2
    tracer.Transparency = 0.8
    tracer.Visible = false
    
    -- 更新連接
    local renderConnection = RunService.RenderStepped:Connect(function()
        if not ESPConfig.MainSwitch or not ESPConfig.ShowTracer then
            tracer.Visible = false
            return
        end
        
        local localChar = LocalPlayer.Character
        local targetChar = player.Character
        
        if not localChar or not targetChar then
            tracer.Visible = false
            return
        end
        
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            local screenPos, isVisible = Camera:WorldToViewportPoint(targetRoot.Position)
            if isVisible then
                tracer.Visible = true
                tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                -- 根據距離調整射線顏色（越近越紅，越遠越黃）
                local distance = (localChar:GetPivot().Position - targetRoot.Position).Magnitude
                if distance < 50 then
                    tracer.Color = Color3.new(1, 0, 0)  -- 紅色
                elseif distance < 100 then
                    tracer.Color = Color3.new(1, 0.5, 0)  -- 橙色
                else
                    tracer.Color = Color3.new(1, 1, 0)  -- 黃色
                end
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end
    end)
    
    ESPElements[player.UserId] = ESPElements[player.UserId] or {}
    ESPElements[player.UserId].Tracer = tracer
    ESPElements[player.UserId].TracerConn = renderConnection
end

-- 更新單個玩家ESP
local function UpdatePlayerESP(player)
    if player == LocalPlayer then return end
    
    -- 清理不再需要的ESP
    if not player.Character or not player.Character:FindFirstChild("Head") then
        CleanupPlayerESP(player)
        return
    end
    
    if ESPConfig.MainSwitch then
        -- 創建/更新信息顯示
        if ESPConfig.ShowPlayerInfo then
            CreatePlayerInfoESP(player)
        else
            if ESPElements[player.UserId] and ESPElements[player.UserId].InfoESP then
                ESPElements[player.UserId].InfoESP:Destroy()
                ESPElements[player.UserId].InfoESP = nil
            end
        end
        
        -- 創建/更新射線追踪
        if ESPConfig.ShowTracer then
            CreateTracerESP(player)
        else
            if ESPElements[player.UserId] and ESPElements[player.UserId].Tracer then
                ESPElements[player.UserId].Tracer:Remove()
                ESPElements[player.UserId].Tracer = nil
            end
        end
    else
        CleanupPlayerESP(player)
    end
end

-- 更新所有玩家ESP
local function UpdateAllESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            UpdatePlayerESP(player)
        end
    end
end

-- 處理玩家重生
local function HandlePlayerRespawn(player)
    if player == LocalPlayer then return end
    
    local character = player.Character
    if not character then
        character = player.CharacterAdded:Wait()
    end
    
    -- 等待必要的部件
    local success = pcall(function()
        local head = character:WaitForChild("Head", 3)
        local rootPart = character:WaitForChild("HumanoidRootPart", 3)
        return head and rootPart
    end)
    
    if success and ESPConfig.MainSwitch then
        task.wait(0.5)  -- 給角色一些時間完全加載
        UpdatePlayerESP(player)
    end
end

-- 初始化ESP系統
task.spawn(function()
    -- 處理新玩家加入
    Players.PlayerAdded:Connect(function(player)
        if player == LocalPlayer then return end
        
        -- 設置角色事件
        player.CharacterAdded:Connect(function()
            task.spawn(function()
                HandlePlayerRespawn(player)
            end)
        end)
        
        player.CharacterRemoving:Connect(function()
            CleanupPlayerESP(player)
        end)
        
        -- 如果玩家已有角色
        if player.Character then
            task.spawn(function()
                HandlePlayerRespawn(player)
            end)
        end
    end)
    
    -- 本地玩家角色重生
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        UpdateAllESP()
    end)
    
    -- 初始處理現有玩家
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            if player.Character then
                task.spawn(function()
                    HandlePlayerRespawn(player)
                end)
            end
            player.CharacterAdded:Connect(function()
                task.spawn(function()
                    HandlePlayerRespawn(player)
                end)
            end)
            player.CharacterRemoving:Connect(function()
                CleanupPlayerESP(player)
            end)
        end
    end
    
    -- 定期更新
    while true do
        task.wait(2)
        if ESPConfig.MainSwitch then
            UpdateAllESP()
        end
    end
end)

-- UI控制
espTab:Toggle("透視總開關", "ESP_Main", false, function(enabled)
    ESPConfig.MainSwitch = enabled
    if enabled then
        UpdateAllESP()
        print("透視系統已開啟")
    else
        for _, player in pairs(Players:GetPlayers()) do
            CleanupPlayerESP(player)
        end
        print("透視系統已關閉")
    end
end)

espTab:Toggle("顯示玩家信息", "ESP_PlayerInfo", false, function(enabled)
    ESPConfig.ShowPlayerInfo = enabled
    UpdateAllESP()
    if enabled then
        print("玩家信息顯示已開啟")
    else
        print("玩家信息顯示已關閉")
    end
end)

espTab:Toggle("射線追踪", "ESP_Tracer", false, function(enabled)
    ESPConfig.ShowTracer = enabled
    UpdateAllESP()
    if enabled then
        print("射線追踪已開啟")
    else
        print("射線追踪已關閉")
    end
end)

espTab:Button("刷新透視", function()
    UpdateAllESP()
    print("透視系統已刷新")
end)

-- ===================== 傳送功能 =====================
local TP = UITab5:section("傳送",false)

TP:Button("傳送至一海", function()
    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("TravelMain")
end)

TP:Button("傳送至二海", function()
    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("TravelDressrosa")
end)

TP:Button("傳送至三海", function()
    game:GetService("ReplicatedStorage").Remotes.CommF_:InvokeServer("TravelZou")
end)

local TP1 = UITab5:section("二海",false)
TP1:Button("傳送至天鵝房間", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-287.37, 305.81, 592.98)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到豪宅:", targetPosition)
    end
end)

TP1:Button("傳送至豪宅", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(2286.93, 15.06, 910.51)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到天鹅的房间:", targetPosition)
    end
end)

TP1:Button("傳送至鬼船里", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-6501.06, 83.11, -123.52)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到鬼船里:", targetPosition)
    end
end)

TP1:Button("傳送至鬼船外", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(922.78, 123.96, 32842.40)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已傳送到鬼船外:", targetPosition)
    end
end)

local TP2 = UITab5:section("三海",false)

TP2:Button("傳送至海洋城堡", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-12463.60, 376.26, -7566.08)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到海洋城堡:", targetPosition)
    end
end)

TP2:Button("傳送至海龟豪宅", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-5060.41, 316.43, -3192.30)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已傳送送到海龟豪宅:", targetPosition)
    end
end)

TP2:Button("傳送至司法", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-5096.48, 316.43, -3177.91)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到司法:", targetPosition)
    end
end)

TP2:Button("傳送至九头蛇", function()
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local targetPosition = Vector3.new(-5027.03, 316.43, -3206.07)
    
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(targetPosition)
        print("已传送到九头蛇:", targetPosition)
    end
end)

-- 快捷命令系統
local function createCommands()
    game:GetService("Players").LocalPlayer.Chatted:Connect(function(msg)
        msg = msg:lower()
        
        if msg == "/attack on" then
            if _ENV.rz_FastAttack then
                _ENV.rz_FastAttack.IsRunning = true
                _G.FastAttack = true
                print("原始攻擊已開啟")
            end
        elseif msg == "/attack off" then
            if _ENV.rz_FastAttack then
                _ENV.rz_FastAttack.IsRunning = false
                _G.FastAttack = false
                print("原始攻擊已關閉")
            end
        elseif msg == "/help" then
            print("========================================")
            print("newhand腳本 命令列表")
            print("/attack on/off - 原始攻擊開關")
            print("/esp on/off - 透視開關")
            print("/speed <數值> - 設置速度")
            print("/v3 on/off - 自動V3開關")
            print("/v4 on/off - 自動V4開關")
            print("/esp refresh - 刷新透視")
            print("========================================")
        elseif msg == "/esp on" then
            ESPConfig.MainSwitch = true
            ESPConfig.ShowPlayerInfo = true
            UpdateAllESP()
            print("透視已開啟（整合顯示模式）")
        elseif msg == "/esp off" then
            ESPConfig.MainSwitch = false
            UpdateAllESP()
            print("透視已關閉")
        elseif msg == "/esp refresh" then
            UpdateAllESP()
            print("透視系統已刷新")
        elseif msg:find("/speed") then
            local speed = tonumber(msg:match("/speed%s+(%d+)"))
            if speed then
                getfenv().translateSpeed = speed
                print("速度已設置為: " .. speed)
            end
        elseif msg == "/v3 on" then
            toggleAutoV3(true)
            print("自動V3已開啟")
        elseif msg == "/v3 off" then
            toggleAutoV3(false)
            print("自動V3已關閉")
        elseif msg == "/v4 on" then
            if not _G.ToggleStates then _G.ToggleStates = {} end
            _G.ToggleStates[toggleKey] = true
            toggleAutoV4(true)
            print("自動V4已開啟")
        elseif msg == "/v4 off" then
            if not _G.ToggleStates then _G.ToggleStates = {} end
            _G.ToggleStates[toggleKey] = false
            toggleAutoV4(false)
            print("自動V4已關閉")
        end
    end)
end

createCommands()

-- 最後的載入完成通知
task.spawn(function()
    task.wait(2)
    print("========================================")
    print("newhand腳本 載入完成")
    print("包含功能:")
    print("1. 自動V3功能 (移植自小傑腳本)")
    print("2. 自動V4功能")
    print("3. 範圍+快速攻擊系統")
    print("4. 整合透視系統 (名稱+距離+血量)")
    print("5. 傳送功能 (全海域)")
    print("6. 移速加速")
    print("7. 防掛機檢測")
    print("8. 外部腳本整合")
    print("========================================")
    print("輸入 /help 查看可用命令")
    print("========================================")
    
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "newhand腳本",
        Text = "載入完成 祝使用愉快\n透視功能已整合為單一顯示",
        Duration = 5
    })
end)
